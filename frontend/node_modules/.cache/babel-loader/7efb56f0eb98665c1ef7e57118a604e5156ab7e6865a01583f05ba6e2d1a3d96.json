{"ast":null,"code":"import _objectSpread from\"C:/Users/iamov/Desktop/Net/tcp-file-transfer/tcp-file-transfer/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// frontend/src/services/api.js\nclass APIService{constructor(){this.baseURL=process.env.REACT_APP_API_URL||'http://localhost:5000/api';this.connected=false;this.clientId=null;this.retryCount=0;this.maxRetries=3;this.retryDelay=1000;this.eventSource=null;}async _fetchWithRetry(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let retries=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.maxRetries;try{const response=await fetch(url,_objectSpread(_objectSpread({},options),{},{credentials:'include',headers:_objectSpread({'Content-Type':'application/json'},options.headers||{})}));if(!response.ok){if(response.status===401&&retries>0){await this.connect();return this._fetchWithRetry(url,options,retries-1);}throw new Error(\"HTTP error! status: \".concat(response.status));}this.retryCount=0;return response;}catch(error){if(retries>0){await new Promise(resolve=>setTimeout(resolve,this.retryDelay*(this.maxRetries-retries+1)));return this._fetchWithRetry(url,options,retries-1);}throw error;}}async connect(){try{const healthResponse=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/health\"));const healthData=await healthResponse.json();if(!this.clientId){const connectResponse=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/connect\"),{method:'POST'});const connectData=await connectResponse.json();this.clientId=connectData.client_id;}this.connected=true;return healthData;}catch(error){this.connected=false;this.clientId=null;throw new Error(\"Failed to connect to server: \".concat(error.message));}}async disconnect(){if(!this.clientId)return;try{await this._fetchWithRetry(\"\".concat(this.baseURL,\"/disconnect\"),{method:'POST',body:JSON.stringify({client_id:this.clientId})});}catch(error){console.error('Disconnection error:',error);}finally{if(this.eventSource){this.eventSource.close();this.eventSource=null;}this.connected=false;this.clientId=null;}}async listFiles(){let path=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/files/list?path=\").concat(encodeURIComponent(path)));return await response.json();}catch(error){throw new Error(\"Failed to list files: \".concat(error.message));}}async downloadFile(filePath,onProgress){try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/files/download?path=\").concat(encodeURIComponent(filePath)));const contentLength=response.headers.get('content-length');const total=parseInt(contentLength,10)||0;let loaded=0;const reader=response.body.getReader();const chunks=[];while(true){const{done,value}=await reader.read();if(done)break;chunks.push(value);loaded+=value.length;if(onProgress&&total>0){onProgress(loaded/total);}}return new Blob(chunks);}catch(error){throw new Error(\"Failed to download file: \".concat(error.message));}}async getClientMetrics(){let clientId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.clientId;if(!clientId)throw new Error('No client ID available');try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/metrics/client/\").concat(clientId));return await response.json();}catch(error){throw new Error(\"Failed to get client metrics: \".concat(error.message));}}async getGlobalMetrics(){try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/metrics/global\"));return await response.json();}catch(error){throw new Error(\"Failed to get global metrics: \".concat(error.message));}}async subscribeToMetrics(callback){if(!this.clientId){throw new Error('No client ID available');}if(this.eventSource){this.eventSource.close();}return new Promise((resolve,reject)=>{try{this.eventSource=new EventSource(\"\".concat(this.baseURL,\"/metrics/stream?client_id=\").concat(this.clientId));this.eventSource.onopen=()=>{console.log('SSE connection established');resolve(()=>{if(this.eventSource){this.eventSource.close();this.eventSource=null;}});};this.eventSource.onmessage=event=>{try{const data=JSON.parse(event.data);callback(data);}catch(err){console.error('Error parsing SSE data:',err);}};this.eventSource.onerror=err=>{console.error('SSE connection error:',err);if(this.eventSource){this.eventSource.close();this.eventSource=null;}reject(err);setTimeout(()=>this.subscribeToMetrics(callback),5000);};}catch(error){reject(error);}});}async startTransfer(filePath){if(!this.clientId)throw new Error('No client ID available');try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/transfer/download?path=\").concat(encodeURIComponent(filePath),\"&client_id=\").concat(this.clientId));return await response.json();}catch(error){throw new Error(\"Failed to start transfer: \".concat(error.message));}}async getTransferStatus(transferId){try{const response=await this._fetchWithRetry(\"\".concat(this.baseURL,\"/transfer/status/\").concat(transferId));return await response.json();}catch(error){throw new Error(\"Failed to get transfer status: \".concat(error.message));}}}const apiService=new APIService();// Auto-connect with retry logic\nconst initializeConnection=async()=>{try{await apiService.connect();console.log('Successfully connected to server');}catch(error){console.error('Initial connection failed, retrying...',error.message);setTimeout(initializeConnection,5000);}};initializeConnection();export default apiService;","map":{"version":3,"names":["APIService","constructor","baseURL","process","env","REACT_APP_API_URL","connected","clientId","retryCount","maxRetries","retryDelay","eventSource","_fetchWithRetry","url","options","arguments","length","undefined","retries","response","fetch","_objectSpread","credentials","headers","ok","status","connect","Error","concat","error","Promise","resolve","setTimeout","healthResponse","healthData","json","connectResponse","method","connectData","client_id","message","disconnect","body","JSON","stringify","console","close","listFiles","path","encodeURIComponent","downloadFile","filePath","onProgress","contentLength","get","total","parseInt","loaded","reader","getReader","chunks","done","value","read","push","Blob","getClientMetrics","getGlobalMetrics","subscribeToMetrics","callback","reject","EventSource","onopen","log","onmessage","event","data","parse","err","onerror","startTransfer","getTransferStatus","transferId","apiService","initializeConnection"],"sources":["C:/Users/iamov/Desktop/Net/tcp-file-transfer/tcp-file-transfer/frontend/src/services/api.js"],"sourcesContent":["// frontend/src/services/api.js\r\nclass APIService {\r\n    constructor() {\r\n        this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\r\n        this.connected = false;\r\n        this.clientId = null;\r\n        this.retryCount = 0;\r\n        this.maxRetries = 3;\r\n        this.retryDelay = 1000;\r\n        this.eventSource = null;\r\n    }\r\n\r\n    async _fetchWithRetry(url, options = {}, retries = this.maxRetries) {\r\n        try {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                credentials: 'include',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    ...(options.headers || {})\r\n                }\r\n            });\r\n\r\n            if (!response.ok) {\r\n                if (response.status === 401 && retries > 0) {\r\n                    await this.connect();\r\n                    return this._fetchWithRetry(url, options, retries - 1);\r\n                }\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            this.retryCount = 0;\r\n            return response;\r\n        } catch (error) {\r\n            if (retries > 0) {\r\n                await new Promise(resolve => setTimeout(resolve, this.retryDelay * (this.maxRetries - retries + 1)));\r\n                return this._fetchWithRetry(url, options, retries - 1);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async connect() {\r\n        try {\r\n            const healthResponse = await this._fetchWithRetry(`${this.baseURL}/health`);\r\n            const healthData = await healthResponse.json();\r\n\r\n            if (!this.clientId) {\r\n                const connectResponse = await this._fetchWithRetry(`${this.baseURL}/connect`, {\r\n                    method: 'POST'\r\n                });\r\n                const connectData = await connectResponse.json();\r\n                this.clientId = connectData.client_id;\r\n            }\r\n\r\n            this.connected = true;\r\n            return healthData;\r\n        } catch (error) {\r\n            this.connected = false;\r\n            this.clientId = null;\r\n            throw new Error(`Failed to connect to server: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async disconnect() {\r\n        if (!this.clientId) return;\r\n\r\n        try {\r\n            await this._fetchWithRetry(`${this.baseURL}/disconnect`, {\r\n                method: 'POST',\r\n                body: JSON.stringify({ client_id: this.clientId })\r\n            });\r\n        } catch (error) {\r\n            console.error('Disconnection error:', error);\r\n        } finally {\r\n            if (this.eventSource) {\r\n                this.eventSource.close();\r\n                this.eventSource = null;\r\n            }\r\n            this.connected = false;\r\n            this.clientId = null;\r\n        }\r\n    }\r\n\r\n    async listFiles(path = '') {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/files/list?path=${encodeURIComponent(path)}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to list files: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async downloadFile(filePath, onProgress) {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/files/download?path=${encodeURIComponent(filePath)}`\r\n            );\r\n\r\n            const contentLength = response.headers.get('content-length');\r\n            const total = parseInt(contentLength, 10) || 0;\r\n            let loaded = 0;\r\n\r\n            const reader = response.body.getReader();\r\n            const chunks = [];\r\n\r\n            while (true) {\r\n                const { done, value } = await reader.read();\r\n                if (done) break;\r\n                chunks.push(value);\r\n                loaded += value.length;\r\n                if (onProgress && total > 0) {\r\n                    onProgress(loaded / total);\r\n                }\r\n            }\r\n\r\n            return new Blob(chunks);\r\n        } catch (error) {\r\n            throw new Error(`Failed to download file: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getClientMetrics(clientId = this.clientId) {\r\n        if (!clientId) throw new Error('No client ID available');\r\n\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/metrics/client/${clientId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get client metrics: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getGlobalMetrics() {\r\n        try {\r\n            const response = await this._fetchWithRetry(`${this.baseURL}/metrics/global`);\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get global metrics: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async subscribeToMetrics(callback) {\r\n        if (!this.clientId) {\r\n            throw new Error('No client ID available');\r\n        }\r\n\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.eventSource = new EventSource(\r\n                    `${this.baseURL}/metrics/stream?client_id=${this.clientId}`\r\n                );\r\n\r\n                this.eventSource.onopen = () => {\r\n                    console.log('SSE connection established');\r\n                    resolve(() => {\r\n                        if (this.eventSource) {\r\n                            this.eventSource.close();\r\n                            this.eventSource = null;\r\n                        }\r\n                    });\r\n                };\r\n\r\n                this.eventSource.onmessage = (event) => {\r\n                    try {\r\n                        const data = JSON.parse(event.data);\r\n                        callback(data);\r\n                    } catch (err) {\r\n                        console.error('Error parsing SSE data:', err);\r\n                    }\r\n                };\r\n\r\n                this.eventSource.onerror = (err) => {\r\n                    console.error('SSE connection error:', err);\r\n                    if (this.eventSource) {\r\n                        this.eventSource.close();\r\n                        this.eventSource = null;\r\n                    }\r\n                    reject(err);\r\n                    setTimeout(() => this.subscribeToMetrics(callback), 5000);\r\n                };\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    async startTransfer(filePath) {\r\n        if (!this.clientId) throw new Error('No client ID available');\r\n\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/transfer/download?path=${encodeURIComponent(filePath)}&client_id=${this.clientId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to start transfer: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getTransferStatus(transferId) {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/transfer/status/${transferId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get transfer status: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n\r\nconst apiService = new APIService();\r\n\r\n// Auto-connect with retry logic\r\nconst initializeConnection = async () => {\r\n    try {\r\n        await apiService.connect();\r\n        console.log('Successfully connected to server');\r\n    } catch (error) {\r\n        console.error('Initial connection failed, retrying...', error.message);\r\n        setTimeout(initializeConnection, 5000);\r\n    }\r\n};\r\n\r\ninitializeConnection();\r\n\r\nexport default apiService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}