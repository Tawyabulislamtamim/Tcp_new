{"ast":null,"code":"// frontend/src/services/api.js\nclass APIService {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n    this.connected = false;\n    this.clientId = null;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n    this.retryDelay = 1000;\n    this.eventSource = null;\n  }\n  async _fetchWithRetry(url, options = {}, retries = this.maxRetries) {\n    try {\n      const response = await fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options.headers || {})\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401 && retries > 0) {\n          await this.connect();\n          return this._fetchWithRetry(url, options, retries - 1);\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      this.retryCount = 0;\n      return response;\n    } catch (error) {\n      if (retries > 0) {\n        await new Promise(resolve => setTimeout(resolve, this.retryDelay * (this.maxRetries - retries + 1)));\n        return this._fetchWithRetry(url, options, retries - 1);\n      }\n      throw error;\n    }\n  }\n  async connect() {\n    try {\n      const healthResponse = await this._fetchWithRetry(`${this.baseURL}/health`);\n      const healthData = await healthResponse.json();\n      if (!this.clientId) {\n        const connectResponse = await this._fetchWithRetry(`${this.baseURL}/connect`, {\n          method: 'POST'\n        });\n        const connectData = await connectResponse.json();\n        this.clientId = connectData.client_id;\n      }\n      this.connected = true;\n      return healthData;\n    } catch (error) {\n      this.connected = false;\n      this.clientId = null;\n      throw new Error(`Failed to connect to server: ${error.message}`);\n    }\n  }\n  async disconnect() {\n    if (!this.clientId) return;\n    try {\n      await this._fetchWithRetry(`${this.baseURL}/disconnect`, {\n        method: 'POST',\n        body: JSON.stringify({\n          client_id: this.clientId\n        })\n      });\n    } catch (error) {\n      console.error('Disconnection error:', error);\n    } finally {\n      if (this.eventSource) {\n        this.eventSource.close();\n        this.eventSource = null;\n      }\n      this.connected = false;\n      this.clientId = null;\n    }\n  }\n  async listFiles(path = '') {\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/files/list?path=${encodeURIComponent(path)}`);\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Failed to list files: ${error.message}`);\n    }\n  }\n  async downloadFile(filePath, onProgress) {\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/files/download?path=${encodeURIComponent(filePath)}`);\n      const contentLength = response.headers.get('content-length');\n      const total = parseInt(contentLength, 10) || 0;\n      let loaded = 0;\n      const reader = response.body.getReader();\n      const chunks = [];\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        chunks.push(value);\n        loaded += value.length;\n        if (onProgress && total > 0) {\n          onProgress(loaded / total);\n        }\n      }\n      return new Blob(chunks);\n    } catch (error) {\n      throw new Error(`Failed to download file: ${error.message}`);\n    }\n  }\n  async getClientMetrics(clientId = this.clientId) {\n    if (!clientId) throw new Error('No client ID available');\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/metrics/client/${clientId}`);\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Failed to get client metrics: ${error.message}`);\n    }\n  }\n  async getGlobalMetrics() {\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/metrics/global`);\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Failed to get global metrics: ${error.message}`);\n    }\n  }\n  async subscribeToMetrics(callback) {\n    if (!this.clientId) {\n      throw new Error('No client ID available');\n    }\n    if (this.eventSource) {\n      this.eventSource.close();\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        this.eventSource = new EventSource(`${this.baseURL}/metrics/stream?client_id=${this.clientId}`);\n        this.eventSource.onopen = () => {\n          console.log('SSE connection established');\n          resolve(() => {\n            if (this.eventSource) {\n              this.eventSource.close();\n              this.eventSource = null;\n            }\n          });\n        };\n        this.eventSource.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            callback(data);\n          } catch (err) {\n            console.error('Error parsing SSE data:', err);\n          }\n        };\n        this.eventSource.onerror = err => {\n          console.error('SSE connection error:', err);\n          if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n          }\n          reject(err);\n          setTimeout(() => this.subscribeToMetrics(callback), 5000);\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  async startTransfer(filePath) {\n    if (!this.clientId) throw new Error('No client ID available');\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/transfer/download?path=${encodeURIComponent(filePath)}&client_id=${this.clientId}`);\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Failed to start transfer: ${error.message}`);\n    }\n  }\n  async getTransferStatus(transferId) {\n    try {\n      const response = await this._fetchWithRetry(`${this.baseURL}/transfer/status/${transferId}`);\n      return await response.json();\n    } catch (error) {\n      throw new Error(`Failed to get transfer status: ${error.message}`);\n    }\n  }\n}\nconst apiService = new APIService();\n\n// Auto-connect with retry logic\nconst initializeConnection = async () => {\n  try {\n    await apiService.connect();\n    console.log('Successfully connected to server');\n  } catch (error) {\n    console.error('Initial connection failed, retrying...', error.message);\n    setTimeout(initializeConnection, 5000);\n  }\n};\ninitializeConnection();\nexport default apiService;","map":{"version":3,"names":["APIService","constructor","baseURL","process","env","REACT_APP_API_URL","connected","clientId","retryCount","maxRetries","retryDelay","eventSource","_fetchWithRetry","url","options","retries","response","fetch","credentials","headers","ok","status","connect","Error","error","Promise","resolve","setTimeout","healthResponse","healthData","json","connectResponse","method","connectData","client_id","message","disconnect","body","JSON","stringify","console","close","listFiles","path","encodeURIComponent","downloadFile","filePath","onProgress","contentLength","get","total","parseInt","loaded","reader","getReader","chunks","done","value","read","push","length","Blob","getClientMetrics","getGlobalMetrics","subscribeToMetrics","callback","reject","EventSource","onopen","log","onmessage","event","data","parse","err","onerror","startTransfer","getTransferStatus","transferId","apiService","initializeConnection"],"sources":["C:/Users/iamov/Desktop/Net/tcp-file-transfer/tcp-file-transfer/frontend/src/services/api.js"],"sourcesContent":["// frontend/src/services/api.js\r\nclass APIService {\r\n    constructor() {\r\n        this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\r\n        this.connected = false;\r\n        this.clientId = null;\r\n        this.retryCount = 0;\r\n        this.maxRetries = 3;\r\n        this.retryDelay = 1000;\r\n        this.eventSource = null;\r\n    }\r\n\r\n    async _fetchWithRetry(url, options = {}, retries = this.maxRetries) {\r\n        try {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                credentials: 'include',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    ...(options.headers || {})\r\n                }\r\n            });\r\n\r\n            if (!response.ok) {\r\n                if (response.status === 401 && retries > 0) {\r\n                    await this.connect();\r\n                    return this._fetchWithRetry(url, options, retries - 1);\r\n                }\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            this.retryCount = 0;\r\n            return response;\r\n        } catch (error) {\r\n            if (retries > 0) {\r\n                await new Promise(resolve => setTimeout(resolve, this.retryDelay * (this.maxRetries - retries + 1)));\r\n                return this._fetchWithRetry(url, options, retries - 1);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async connect() {\r\n        try {\r\n            const healthResponse = await this._fetchWithRetry(`${this.baseURL}/health`);\r\n            const healthData = await healthResponse.json();\r\n\r\n            if (!this.clientId) {\r\n                const connectResponse = await this._fetchWithRetry(`${this.baseURL}/connect`, {\r\n                    method: 'POST'\r\n                });\r\n                const connectData = await connectResponse.json();\r\n                this.clientId = connectData.client_id;\r\n            }\r\n\r\n            this.connected = true;\r\n            return healthData;\r\n        } catch (error) {\r\n            this.connected = false;\r\n            this.clientId = null;\r\n            throw new Error(`Failed to connect to server: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async disconnect() {\r\n        if (!this.clientId) return;\r\n\r\n        try {\r\n            await this._fetchWithRetry(`${this.baseURL}/disconnect`, {\r\n                method: 'POST',\r\n                body: JSON.stringify({ client_id: this.clientId })\r\n            });\r\n        } catch (error) {\r\n            console.error('Disconnection error:', error);\r\n        } finally {\r\n            if (this.eventSource) {\r\n                this.eventSource.close();\r\n                this.eventSource = null;\r\n            }\r\n            this.connected = false;\r\n            this.clientId = null;\r\n        }\r\n    }\r\n\r\n    async listFiles(path = '') {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/files/list?path=${encodeURIComponent(path)}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to list files: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async downloadFile(filePath, onProgress) {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/files/download?path=${encodeURIComponent(filePath)}`\r\n            );\r\n\r\n            const contentLength = response.headers.get('content-length');\r\n            const total = parseInt(contentLength, 10) || 0;\r\n            let loaded = 0;\r\n\r\n            const reader = response.body.getReader();\r\n            const chunks = [];\r\n\r\n            while (true) {\r\n                const { done, value } = await reader.read();\r\n                if (done) break;\r\n                chunks.push(value);\r\n                loaded += value.length;\r\n                if (onProgress && total > 0) {\r\n                    onProgress(loaded / total);\r\n                }\r\n            }\r\n\r\n            return new Blob(chunks);\r\n        } catch (error) {\r\n            throw new Error(`Failed to download file: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getClientMetrics(clientId = this.clientId) {\r\n        if (!clientId) throw new Error('No client ID available');\r\n\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/metrics/client/${clientId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get client metrics: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getGlobalMetrics() {\r\n        try {\r\n            const response = await this._fetchWithRetry(`${this.baseURL}/metrics/global`);\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get global metrics: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async subscribeToMetrics(callback) {\r\n        if (!this.clientId) {\r\n            throw new Error('No client ID available');\r\n        }\r\n\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                this.eventSource = new EventSource(\r\n                    `${this.baseURL}/metrics/stream?client_id=${this.clientId}`\r\n                );\r\n\r\n                this.eventSource.onopen = () => {\r\n                    console.log('SSE connection established');\r\n                    resolve(() => {\r\n                        if (this.eventSource) {\r\n                            this.eventSource.close();\r\n                            this.eventSource = null;\r\n                        }\r\n                    });\r\n                };\r\n\r\n                this.eventSource.onmessage = (event) => {\r\n                    try {\r\n                        const data = JSON.parse(event.data);\r\n                        callback(data);\r\n                    } catch (err) {\r\n                        console.error('Error parsing SSE data:', err);\r\n                    }\r\n                };\r\n\r\n                this.eventSource.onerror = (err) => {\r\n                    console.error('SSE connection error:', err);\r\n                    if (this.eventSource) {\r\n                        this.eventSource.close();\r\n                        this.eventSource = null;\r\n                    }\r\n                    reject(err);\r\n                    setTimeout(() => this.subscribeToMetrics(callback), 5000);\r\n                };\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    async startTransfer(filePath) {\r\n        if (!this.clientId) throw new Error('No client ID available');\r\n\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/transfer/download?path=${encodeURIComponent(filePath)}&client_id=${this.clientId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to start transfer: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    async getTransferStatus(transferId) {\r\n        try {\r\n            const response = await this._fetchWithRetry(\r\n                `${this.baseURL}/transfer/status/${transferId}`\r\n            );\r\n            return await response.json();\r\n        } catch (error) {\r\n            throw new Error(`Failed to get transfer status: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n\r\nconst apiService = new APIService();\r\n\r\n// Auto-connect with retry logic\r\nconst initializeConnection = async () => {\r\n    try {\r\n        await apiService.connect();\r\n        console.log('Successfully connected to server');\r\n    } catch (error) {\r\n        console.error('Initial connection failed, retrying...', error.message);\r\n        setTimeout(initializeConnection, 5000);\r\n    }\r\n};\r\n\r\ninitializeConnection();\r\n\r\nexport default apiService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}